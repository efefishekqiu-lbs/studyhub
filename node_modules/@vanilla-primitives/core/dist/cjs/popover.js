'use strict';

class Popover {
    constructor(element) {
        this.root = element;
        this.trigger = this.root.querySelector("[data-popover-trigger]");
        this.content = this.root.querySelector("[data-popover-content]");

        this.setupAccessibility();
        this.setupEventListeners();
        this.setState("closed"); // Initialize the state
        this.isAnimating = false; // Flag to track animation state
    }

    generateId(prefix) {
        return `${prefix}-${Math.random().toString(36).slice(2, 11)}`;
    }

    setAriaAttributes(element, attrs) {
        Object.entries(attrs).forEach(([key, value]) => element?.setAttribute(key, value));
    }

    setupAccessibility() {
        const { content, trigger } = this;

        this.setAriaAttributes(content, {
            role: "dialog",
            id: this.generateId("popover-content")
        });

        this.setAriaAttributes(trigger, {
            "aria-haspopup": "dialog",
            "aria-expanded": "false",
            "aria-controls": content.id
        });
    }

    setupEventListeners() {
        this.trigger?.addEventListener("click", (e) => {
            e.stopPropagation();
            this.toggle();
        });
        
        // Use capturing for the document click listener
        document.addEventListener("click", this.handleDocumentClick.bind(this), true);

        // Add global keydown event listener for Escape key
        document.addEventListener("keydown", this.handleGlobalKeyDown.bind(this));

        // Prevent focus on trigger when hovering
        this.trigger.addEventListener("mouseover", (e) => {
            e.preventDefault();
            if (this.isOpen()) {
                e.stopPropagation();
            }
        });
    }

    handleDocumentClick(e) {
        // Check if the click is outside both the trigger and the content
        if (!this.root.contains(e.target) && this.isOpen()) {
            this.close();
        }
    }

    handleGlobalKeyDown(e) {
        if (e.key === "Escape" && this.isOpen()) {
            this.close();
            this.trigger.focus();
        }
    }

    setState(state) {
        this.content.setAttribute("data-state", state);
    }

    toggle() {
        this.isOpen() ? this.close() : this.open();
    }

    open() {
        if (this.isAnimating) return; // Prevent opening if animation is already in progress

        // Close all other open popovers first
        document.querySelectorAll('[data-popover-content][data-state="open"]').forEach(openPopover => {
            if (openPopover !== this.content) {
                openPopover.dispatchEvent(new CustomEvent('closePopover'));
            }
        });

        this.content.classList.remove("hidden");
        this.trigger.setAttribute("aria-expanded", "true");
        this.setState("open");

        // Focus the first focusable element immediately after opening
        const firstFocusableElement = this.getFirstFocusableElement();
        if (firstFocusableElement) {
            firstFocusableElement.focus();
        }

        const styles = window.getComputedStyle(this.content);
        const hasEnterAnimation = styles.animationName !== 'none' && styles.display !== 'none';

        if (hasEnterAnimation) {
            this.isAnimating = true;
            const handleAnimationEnd = () => {
                this.isAnimating = false;
                this.content.removeEventListener("animationend", handleAnimationEnd);
            };

            this.content.addEventListener("animationend", handleAnimationEnd);
        }
        // If there's no animation, we don't set isAnimating to true
    }

    close() {
        if (this.isAnimating) return; // Prevent closing if animation is already in progress

        this.setState("closed");
        this.trigger.setAttribute("aria-expanded", "false");
        
        const styles = window.getComputedStyle(this.content);
        const hasExitAnimation = styles.animationName !== 'none' && styles.display !== 'none';
        if (hasExitAnimation) {
            this.isAnimating = true; // Set isAnimating only if there's an animation
            const handleAnimationEnd = () => {
                this.content.classList.add("hidden");
                this.isAnimating = false;
                this.content.removeEventListener("animationend", handleAnimationEnd);
            };
            
            this.content.addEventListener("animationend", handleAnimationEnd);
        } else {
            // If there's no animation, immediately hide the content
            this.content.classList.add("hidden");
            // We don't set isAnimating to true here since there's no animation
        }
    }


    isOpen() {
        return this.content.getAttribute("data-state") === "open";
    }

    getFirstFocusableElement() {
        const focusableElements = this.content.querySelectorAll(
            'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
        );
        return focusableElements.length > 0 ? focusableElements[0] : null;
    }
}

module.exports = Popover;
//# sourceMappingURL=popover.js.map
