'use strict';

class Calendar {
    constructor(container, options = {}) {
        this.container = container;
        this.date = new Date();
        this.options = {
            showOutsideDays: true,
            ...options
        };
        this.classNames = {
            calendar: "",
            months: "",
            month: "",
            caption: "",
            caption_label: "",
            nav: "",
            nav_button: "",
            nav_button_previous: "",
            nav_button_next: "",
            table: "",
            head_row: "",
            head_cell: "",
            row: "",
            cell: "",
            day: "",
            day_range_end: "",
            day_selected: "",
            day_today: "",
            day_outside: "",
            day_disabled: "",
            day_range_middle: "",
            day_hidden: "",
            ...options.classNames
        };
        this.components = {
            IconLeft: '&lt;',
            IconRight: '&gt;',
            ...options.components
        };
        this.selected = null;
        this.focusedDate = null;
        this.setFocusedDate(); // Set initial focused date
        if (options.selected) {
            this.setSelectedDate(options.selected);
        }
        this.monthYearElement = null;
        this.tableBodyElement = null;
        this.render();
        this.addEventListeners();
    }

    render() {
        if (!this.container.firstChild) {
            this.initialRender();
        } else {
            this.updateCalendar();
        }
    }

    setFocusedDate() {
        let potentialFocusDate;

        if (this.selected && !this.isDisabled(this.selected)) {
            potentialFocusDate = new Date(this.selected);
        } else {
            const today = new Date();
            if (this.isToday(this.date) && !this.isDisabled(today)) {
                potentialFocusDate = today;
            } else {
                potentialFocusDate = new Date(this.date);
            }
        }

        // If the potential focus date is disabled or outside the current month, find the first available date
        if (this.isDisabled(potentialFocusDate) || potentialFocusDate.getMonth() !== this.date.getMonth()) {
            const currentMonth = this.date.getMonth();
            const currentYear = this.date.getFullYear();

            // Check all days in the current month
            for (let i = 1; i <= 31; i++) {
                const checkDate = new Date(currentYear, currentMonth, i);
                if (checkDate.getMonth() !== currentMonth) break; // Stop if we've moved to the next month
                if (!this.isDisabled(checkDate)) {
                    potentialFocusDate = checkDate;
                    break;
                }
            }
        }

        this.focusedDate = potentialFocusDate;
    }
    initialRender() {
        const year = this.date.getFullYear();
        const month = this.date.getMonth();
        const monthName = this.getMonthName(month);

        this.container.innerHTML = `
        <div class="${this.classNames.calendar}" role="application" aria-label="Calendar">
          <div class="${this.classNames.months}">
            <div class="${this.classNames.month}">
              <div class="${this.classNames.caption}" role="heading" aria-level="1">
                <button class="${this.classNames.nav_button} ${this.classNames.nav_button_previous}" id="prevMonth" aria-label="Previous month">
                  ${this.components.IconLeft}
                </button>
                <span class="${this.classNames.caption_label}" id="monthYear">${monthName} ${year}</span>
                <button class="${this.classNames.nav_button} ${this.classNames.nav_button_next}" id="nextMonth" aria-label="Next month">
                  ${this.components.IconRight}
                </button>
              </div>
              <table class="${this.classNames.table}" role="grid" aria-labelledby="monthYear">
                <thead>
                  <tr class="${this.classNames.head_row}">
                    ${this.getDayNames().map(day => `<th class="${this.classNames.head_cell}" scope="col" aria-label="${day}">${day}</th>`).join('')}
                  </tr>
                </thead>
                <tbody>
                  ${this.renderCalendarDays()}
                </tbody>
              </table>
            </div>
          </div>
        </div>
        `;

        this.monthYearElement = this.container.querySelector('#monthYear');
        this.tableBodyElement = this.container.querySelector('tbody');
    }

    updateCalendar() {
        if (!this.monthYearElement || !this.tableBodyElement) {
            this.initialRender();
            return;
        }

        const year = this.date.getFullYear();
        const month = this.date.getMonth();
        const monthName = this.getMonthName(month);

        this.monthYearElement.textContent = `${monthName} ${year}`;
        this.tableBodyElement.innerHTML = this.renderCalendarDays();
    }

    renderCalendarDays() {
        const year = this.date.getFullYear();
        const month = this.date.getMonth();
        return this.getCalendarDays(year, month).map((week, weekIndex) => `
            <tr class="${this.classNames.row}">
                ${week.map((day, dayIndex) => `
                    <td class="${this.classNames.cell}" role="gridcell">
                        ${day.isEmpty
                ? `<div role="gridcell"></div>`
                : `<button class="${this.getButtonClasses(day)}" 
                                data-date="${day.fullDate ? day.fullDate.toISOString() : ''}" 
                                tabindex="${this.isFocused(day.fullDate) ? '0' : '-1'}"
                                aria-label="${this.getAriaLabel(day)}"
                                aria-pressed="${day.isSelected ? 'true' : 'false'}"
                                ${day.isDisabled ? 'disabled' : ''}
                              >${day.date}</button>`
            }
                    </td>
                `).join('')}
            </tr>
        `).join('');
    }

    addEventListeners() {
        this.container.querySelector('#prevMonth').addEventListener('click', () => this.changeMonth(-1));
        this.container.querySelector('#nextMonth').addEventListener('click', () => this.changeMonth(1));
        this.updateEventListeners();
    }

    updateEventListeners() {
        const dateButtons = this.container.querySelectorAll('button[data-date]');
        dateButtons.forEach(button => {
            button.addEventListener('click', (e) => this.onDateSelect(e));
            button.addEventListener('keydown', (e) => this.onKeyDown(e));
            button.addEventListener('focus', (e) => this.onFocus(e));
        });
    }

    onKeyDown(event) {
        const key = event.key;
        const currentButton = event.target;
        const currentDate = new Date(currentButton.getAttribute('data-date'));

        let newDate;
        switch (key) {
            case 'ArrowRight':
                newDate = new Date(currentDate.setDate(currentDate.getDate() + 1));
                break;
            case 'ArrowLeft':
                newDate = new Date(currentDate.setDate(currentDate.getDate() - 1));
                break;
            case 'ArrowUp':
                newDate = new Date(currentDate.setDate(currentDate.getDate() - 7));
                break;
            case 'ArrowDown':
                newDate = new Date(currentDate.setDate(currentDate.getDate() + 7));
                break;
            case 'Home':
                // Set to the first day (Sunday) of the current week
                newDate = new Date(currentDate);
                newDate.setDate(currentDate.getDate() - currentDate.getDay());
                break;
            case 'End':
                // Set to the last day (Saturday) of the current week
                newDate = new Date(currentDate);
                newDate.setDate(currentDate.getDate() + (6 - currentDate.getDay()));
                break;
            case 'PageUp':
                if (event.shiftKey) {
                    newDate = new Date(currentDate.getFullYear() - 1, currentDate.getMonth(), 1);
                } else {
                    newDate = new Date(currentDate.getFullYear(), currentDate.getMonth() - 1, 1);
                }
                newDate.setDate(Math.min(currentDate.getDate(), this.getDaysInMonth(newDate.getFullYear(), newDate.getMonth())));
                break;
            case 'PageDown':
                if (event.shiftKey) {
                    newDate = new Date(currentDate.getFullYear() + 1, currentDate.getMonth(), 1);
                } else {
                    newDate = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 1);
                }
                newDate.setDate(Math.min(currentDate.getDate(), this.getDaysInMonth(newDate.getFullYear(), newDate.getMonth())));
                break;
            default:
                return; // Exit for other keys
        }

        event.preventDefault();
        this.navigateToDate(newDate);
    }
    getDaysInMonth(year, month) {
        return new Date(year, month + 1, 0).getDate();
    }
    onFocus(event) {
        const button = event.target;
        this.focusedDate = new Date(button.getAttribute('data-date'));
        this.updateTabIndex();
    }

    navigateToDate(date) {
        const currentMonth = this.date.getMonth();
        const currentYear = this.date.getFullYear();

        if (date.getMonth() !== currentMonth || date.getFullYear() !== currentYear) {
            this.date = new Date(date);
            this.updateCalendar();
            this.updateEventListeners();
        }

        this.focusedDate = date;
        this.updateTabIndex();

        const newButton = this.container.querySelector(`button[data-date="${date.toISOString()}"]`);
        if (newButton) {
            newButton.focus();
        }
    }

    updateTabIndex() {
        const dateButtons = this.container.querySelectorAll('button[data-date]');

        dateButtons.forEach(btn => {
            const btnDate = new Date(btn.getAttribute('data-date'));
            if (this.isFocused(btnDate)) {
                btn.setAttribute('tabindex', '0');
            } else {
                btn.setAttribute('tabindex', '-1');
            }
        });
    }

    getButtonClasses(day) {
        let classes = [this.classNames.day];
        if (day.isToday) classes.push(this.classNames.day_today);
        if (day.isOutside) classes.push(this.classNames.day_outside);
        if (day.isSelected) classes.push(this.classNames.day_selected);
        if (day.isDisabled) classes.push(this.classNames.day_disabled);
        if (day.isEmpty) classes.push(this.classNames.day_hidden);
        return classes.join(' ');
    }

    getAriaLabel(day) {
        const date = day.fullDate;
        const dayName = this.getDayNames()[date.getDay()];
        const monthName = this.getMonthName(date.getMonth());
        let label = `${dayName}, ${monthName} ${date.getDate()}, ${date.getFullYear()}`;
        if (day.isToday) label += ', Today';
        if (day.isSelected) label += ', Selected';
        if (day.isDisabled) label += ', Disabled';
        return label;
    }

    getMonthName(month) {
        const monthNames = ["January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"
        ];
        return monthNames[month];
    }

    getDayNames() {
        return ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    }

    getCalendarDays(year, month) {
        const firstDay = new Date(year, month, 1);
        const lastDay = new Date(year, month + 1, 0);
        const daysInMonth = lastDay.getDate();
        const startingDay = firstDay.getDay();

        let days = [];
        let week = [];

        // Previous month's days
        if (this.options.showOutsideDays) {
            for (let i = startingDay - 1; i >= 0; i--) {
                const date = new Date(year, month, -i);
                week.push(this.createDayObject(date, true));
            }
        } else {
            // Add empty cells for the start of the month
            for (let i = 0; i < startingDay; i++) {
                week.push(this.createEmptyDayObject());
            }
        }

        // Current month's days
        for (let i = 1; i <= daysInMonth; i++) {
            const date = new Date(year, month, i);
            week.push(this.createDayObject(date));
            if (week.length === 7) {
                days.push(week);
                week = [];
            }
        }

        // Next month's days or empty cells
        if (week.length > 0) {
            if (this.options.showOutsideDays) {
                for (let i = 1; week.length < 7; i++) {
                    const date = new Date(year, month + 1, i);
                    week.push(this.createDayObject(date, true));
                }
            } else {
                // Add empty cells for the end of the month
                while (week.length < 7) {
                    week.push(this.createEmptyDayObject());
                }
            }
            days.push(week);
        }

        return days;
    }

    createEmptyDayObject() {
        return {
            date: null,
            fullDate: null,
            isOutside: true,
            isToday: false,
            isSelected: false,
            isDisabled: true,
            isEmpty: true
        };
    }

    createDayObject(date, isOutside = false) {
        return {
            date: date.getDate(),
            fullDate: date,
            isOutside,
            isToday: this.isToday(date),
            isSelected: this.isSelected(date),
            isDisabled: this.isDisabled(date) || isOutside
        };
    }

    isToday(date) {
        const today = new Date();
        return date.getDate() === today.getDate() &&
            date.getMonth() === today.getMonth() &&
            date.getFullYear() === today.getFullYear();
    }

    isSelected(date) {
        if (!this.selected) return false;
        return date.getDate() === this.selected.getDate() &&
            date.getMonth() === this.selected.getMonth() &&
            date.getFullYear() === this.selected.getFullYear();
    }

    isFocused(date) {
        return this.focusedDate &&
            date.getDate() === this.focusedDate.getDate() &&
            date.getMonth() === this.focusedDate.getMonth() &&
            date.getFullYear() === this.focusedDate.getFullYear();
    }

    isDisabled(date) {
        // Implement your own logic for disabled dates
        return false;
    }

    changeMonth(delta) {
        this.date.setMonth(this.date.getMonth() + delta);
        this.setFocusedDate(); // Update focused date when changing months
        this.updateCalendar();
        this.updateEventListeners();

        // Update tab index for the new month without focusing
        this.updateTabIndex();
    }

    onDateSelect(event) {
        const button = event.target;
        const clickedDate = new Date(button.getAttribute('data-date'));

        // Toggle selection
        if (this.isSelected(clickedDate)) {
            this.selected = null;
        } else {
            this.selected = clickedDate;
        }

        this.focusedDate = clickedDate;
        this.updateTabIndex();

        // Update all day buttons
        const dateButtons = this.container.querySelectorAll('button[data-date]');
        dateButtons.forEach(btn => {
            const btnDate = new Date(btn.getAttribute('data-date'));
            this.updateButtonClasses(btn, btnDate);
            btn.setAttribute('aria-pressed', this.isSelected(btnDate) ? 'true' : 'false');
        });

        if (this.options.onSelect) {
            this.options.onSelect(this.selected);
        }
    }

    updateButtonClasses(button, date) {
        const dayObject = this.createDayObject(date, date.getMonth() !== this.date.getMonth());
        button.className = this.getButtonClasses(dayObject);
    }

    setSelectedDate(date) {
        if (date instanceof Date) {
            this.selected = new Date(date);
            this.focusedDate = new Date(date);
            this.date = new Date(date);  // Update the current month view to the selected date
            this.render();
            this.addEventListeners();
        }
    }

    // Public methods for customization
    setClassNames(newClassNames) {
        this.classNames = { ...this.classNames, ...newClassNames };
        this.render();
        this.addEventListeners();
    }

    setComponents(newComponents) {
        this.components = { ...this.components, ...newComponents };
        this.render();
        this.addEventListeners();
    }

    setOptions(newOptions) {
        this.options = { ...this.options, ...newOptions };
        this.render();
        this.addEventListeners();
    }
}

module.exports = Calendar;
//# sourceMappingURL=calendar.js.map
