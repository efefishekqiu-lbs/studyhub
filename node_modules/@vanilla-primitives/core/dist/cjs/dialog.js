'use strict';

/*
Implementation Notes for Dialog :

1. Current Approach:
   - We use the native <dialog> element to align with HTML standards.
   - Custom open/close methods are implemented to add animation support.
   - This approach prioritizes standards compliance and future-proofing.

2. Animation Implementation:
   - Currently overriding the showModal and close methods to handle animations.
   - While keyframe animations are possible with <dialog>, they don't support animating the backdrop.
   - Our current method allows us to animate both the dialog and its backdrop.

3. Future Improvement with @starting-style:
   - Once browser support improves, we plan to transition to the @starting-style at-rule.
   - Syntax: @starting-style { dialog { opacity: 0; transform: scale(0.5); } }
   - Animations will work natively with dialog.showModal() and dialog.close(). 
   - Will allow use of native dialog.showModal() and dialog.close() with animations. No more close() and open() methods in here anymore the animations will just work!

4. Why <dialog>:
   - Using <dialog> ensures long-term compatibility with evolving web standards.
   - It simplifies maintenance as browsers improve native dialog implementation.
   - While it presents some animation challenges now, it's a forward-looking choice.

5. Current JavaScript Complexity:
   - The current implementation requires JavaScript to handle animations and events.
   - This includes managing animation states, intercepting form events, and custom open/close logic.
   - @starting-style will allow us to move this logic to CSS, simplifying the JavaScript significantly.

TODO: 
- Monitor browser support for @starting-style and update implementation when widely supported.
- Plan refactoring to remove custom animation logic and event handling once @starting-style is implemented.

Resources:
https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dialog#animating_dialogs
https://developer.mozilla.org/en-US/docs/Web/CSS/@starting-style
*/
class Dialog {
    constructor(element, options = {}) {
        this.root = element;
        this.dialog = this.root;
        this.cancelButton = this.root.querySelector("[data-dialog-cancel]");
        this.title = this.root.querySelector("[data-dialog-title]");
        this.description = this.root.querySelector("[data-dialog-description]");
        this.isAnimating = false;
        this.options = options;

        this.setupAccessibility();
        this.setupEventListeners();
        this.attachCustomMethods();
    }

    generateId(prefix) {
        return `${prefix}-${Math.random().toString(36).slice(2, 11)}`;
    }

    attachCustomMethods() {
        this.originalCloseModal = this.dialog.close;
        this.originalShowModal = this.dialog.showModal;
        this.dialog.close = () => this.close();
        this.dialog.showModal = () => this.open();
    }

    setAriaAttributes(element, attrs) {
        if (element) {
            Object.entries(attrs).forEach(([key, value]) => element.setAttribute(key, value));
        }
    }

    setupAccessibility() {
        const { dialog, title, description, options } = this;

        this.setAriaAttributes(dialog, {
            role: options.isAlert ? "alertdialog" : "dialog",
            "aria-modal": "true",
            "aria-labelledby": title ? this.generateId("dialog-title") : "",
            "aria-describedby": description ? this.generateId("dialog-description") : ""
        });

        if (title) title.id = dialog.getAttribute("aria-labelledby") || "";
        else console.warn("Dialog is missing a title for accessibility.");

        if (description) description.id = dialog.getAttribute("aria-describedby") || "";
        else console.warn("Dialog is missing a description for accessibility.");
    }

    setupEventListeners() {
        this.cancelButton?.addEventListener("click", () => this.close());
        
        this.dialog?.addEventListener("keydown", (e) => {
            if (e.key === "Escape") {
                e.preventDefault();
                this.close();
            }
        });

        // Handle multiple form elements
        const forms = this.dialog.querySelectorAll('form');
        forms.forEach(form => {
            form.addEventListener('submit', (e) => {
                if (form.method === 'dialog') {
                    e.preventDefault();
                    this.close();
                }
            });
        });
    }

    open() {
        if (this.isAnimating) return;

        this.originalShowModal.call(this.dialog);
        this.setAriaAttributes(this.dialog, { "data-state": "open" });
        document.body.style.overflow = 'hidden';

        const styles = window.getComputedStyle(this.dialog);
        const hasEnterAnimation = styles.animationName !== 'none' && styles.display !== 'none';

        if (hasEnterAnimation) {
            this.isAnimating = true;
            const handleAnimationEnd = () => {
                this.isAnimating = false;
                this.dialog.removeEventListener("animationend", handleAnimationEnd);
            };
            this.dialog.addEventListener("animationend", handleAnimationEnd);
        }
    }

    close() {
        if (this.isAnimating) return;

        this.setAriaAttributes(this.dialog, { "data-state": "closed" });
        
        const styles = window.getComputedStyle(this.dialog);
        const hasExitAnimation = styles.animationName !== 'none' && styles.display !== 'none';

        if (hasExitAnimation) {
            this.isAnimating = true;
            const handleAnimationEnd = () => {
                this.finishClosing();
                this.isAnimating = false;
                this.dialog.removeEventListener("animationend", handleAnimationEnd);
            };
            this.dialog.addEventListener("animationend", handleAnimationEnd);
        } else {
            this.finishClosing();
        }
    }

    finishClosing() {
        this.originalCloseModal.call(this.dialog);
        document.body.style.overflow = '';
    }
}

module.exports = Dialog;
//# sourceMappingURL=dialog.js.map
